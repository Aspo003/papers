\section{Technical details}\label{sec:technical}

The interface for \pkg{iNZight} is developed entirely within \proglang{R}, made possible by three main packages. \pkg{gWidgets2} \citep{gWidgets2} and \pkg{gWidgets2RGtk2} \citep{gWidgets2RGtk2} provide a simple widget-based \gls{api} to building an cross-platform interface with \proglang{R}. The second package, \pkg{gWidgets2RGtk2}, is an interfacing package which provides a lower-level wrapper for the more complex functionality within the \pkg{RGtk2} package \citep{RGtk2}, which itself calls back to \proglang{C} libraries for the GTK+ \citep{gtk} windowing system. Together, these packages provide a platform- and library-independent \gls{api} for creating windows with uesr inputs from \proglang{R}.

The framework used to build \pkg{iNZight} is an \gls{oop} framework, which is well suited to \glspl{gui}, of which there are several within \proglang{R}. \pkg{iNZight} uses \emph{reference classes}, which are also used by \pkg{gWidgets2}, to describe individual components of the interface. Each panel is a \emph{class}, with individual buttons, methods (actions), and even smaller components which are themselves classes. \Gls{oop} also allows for \emph{inheritance}, which allows developers to describe a general class which can be shared to several related components, but which may have different layouts or methods. FIGURE shows the \pkg{iNZight} \gls{gui} with some of the major class components annotated.

The structure of each class is, in most cases, a set of attributes that the user can control, stored as \emph{properties} of the class. There is also a set of \emph{methods} which can be used by the class to react to user input, or perform actions. Most components have a main \emph{action} method, which performs the primary action of the component. For example, the \class{iNZFilterData} class contains a \fct{filter\_data} method. These main functions collect the user's input and pass them to one or more \emph{wrapper} functions; in the case of \class{iNZFilterData}, one of the functions is \fct{iNZightTools::filterNumeric}. A skeleton example of the \menu{Filter Data} window class is shown below:
\begin{Code}
iNZFilterData <- setRefClass(
    "iNZFilterData",
    propoerties = list(
        GUI = "ANY",
        data = "data.frame",
        type = "ANY",
        variable = "ANY",
        operator = "ANY",
        value = "ANY",
        ...
    ),
    methods = list(
        initialize = function(gui) {
            initFields(GUI = gui, data = gui$getActiveData())
            # ... construct GUI inputs ...
            # e.g.,
            variable <<- gcombobox(colnames(data))
            okbtn <- gbutton("Filter", handler = function(h, ...) filter_data())
        },
        filter_data = function() {
            filtered_data <- switch(type,
                "numeric" = iNZightTools::filterNumeric(
                    data,
                    var = variable,
                    op = operator,
                    num = value),
                ...
            )
            GUI$update_data(filtered_data)
        }
    )
)
\end{Code}
In this oversimplified example, the user will be displayed a drop down \fct{gcombobox} to choose a variable to filter on. When they click the button, the data will be filtered and passed back to the main \gls{gui}. The filtering uses the \fct{switch} function to select the wrapper based on the users selection (not shown to save space).


Each major component has a similiar structure, and calls to various functions, many of which come from wrappers in other \pkg{iNZight*} packages. For example, plots are generated by calls to \fct{iNZightPlots::inzplot}, while data import is handled by \fct{iNZightTools::smart\_read}. This function uses the file extension to guess the file type and load the data using the appropriate methods. The wrappers enfore the desired structure, where the interface asks for the values of arguments to be passed, and keeps the data-specific logic out of the \gls{gui}.

<<quick_hack,echo=FALSE>>=
code <- function(x) tidy_all_code(iNZightTools::code(x))
@
A second advantage is that the individual wrapper functions can be designed to include the lower-level \proglang{R} code used to generate the result, which the \gls{gui} can fetch from the returned data and attach to the script. Here is an example of the result returned by \fct{iNZightTools::smart\_read} (which can read from a remote URL):
<<code_from_result>>=
library("iNZightTools")
url <- paste0("https://www.stat.auckland.ac.nz/~wild/data/data_from_iNZight/",
    "Census%20at%20School-500.csv")
data <- smart_read(url)
cat(code(data), sep = "\n")
@

\begin{itemize}
    \item describe sub-packages (TABLE: plots/regression/etc)
    \item diving deeper: data stored in \emph{Documents}, each with a dataset/info about it; plots settings, variable choices, etc
    \begin{itemize}
        \item users can switch between documents (data sets)
        \item or merge them
    \end{itemize}
\end{itemize}


\subsection{Usage}\label{sec:usage}

\begin{itemize}
    \item its an \proglang{R} package
    \item \gls{gui} is a single reference class object, \class{iNZGUI}
<<manual_usage,eval=FALSE>>=
library(iNZight)
ui <- iNZGUI$new()
ui$initializeGui()
@
    \item however, include a wrapper to make easier startup:
<<manual_usage2,eval=FALSE>>=
iNZight()
@
    \item For development, first option is better since it provides direct access to the objects:
<<manual_usage,eval=FALSE>>=
ui$getActiveData()
ui$ctrlWidget$V1box$set_value("height")
@
\end{itemize}
