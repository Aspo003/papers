\section{Technical details}\label{sec:technical}

The interface for \pkg{iNZight} is developed entirely within \proglang{R}, made possible by three main packages. \pkg{gWidgets2} \citep{gWidgets2} and \pkg{gWidgets2RGtk2} \citep{gWidgets2RGtk2} provide a simple widget-based \gls{api} to building an cross-platform interface with \proglang{R}. The second package, \pkg{gWidgets2RGtk2}, is an interfacing package which provides a lower-level wrapper for the more complex functionality within the \pkg{RGtk2} package \citep{RGtk2}, which itself calls back to \proglang{C} libraries for the GTK+ \citep{gtk} windowing system. Together, these packages provide a platform- and library-independent \gls{api} for creating windows with uesr inputs from \proglang{R}.

The framework used to build \pkg{iNZight} is an \gls{oop} framework, which is well suited to \glspl{gui}, of which there are several within \proglang{R}. \pkg{iNZight} uses \emph{reference classes}, which are also used by \pkg{gWidgets2}, to describe individual components of the interface. Each panel is a \emph{class}, with individual buttons, methods (actions), and even smaller components which are themselves classes. \Gls{oop} also allows for \emph{inheritance}, which allows developers to describe a general class which can be shared to several related components, but which may have different layouts or methods. \Cref{fig:inzight_main_widgets} shows the \pkg{iNZight} \gls{gui} with some of the major class components annotated.

\begin{figure}[tp]
    \centering
    \includegraphics[width=\textwidth]{figure/inzight_main_widgets.png}
    \caption[The reference class components of the iNZight interface.]{\label{fig:inzight_main_widgets} The reference class components of the \pkg{iNZight} interface, some of which are themselves made from several child objects.}
\end{figure}


The structure of each class is, in most cases, a set of attributes that the user can control, stored as \emph{properties} of the class. There is also a set of \emph{methods} which can be used by the class to react to user input, or perform actions. Most components have a main \emph{action} method, which performs the primary action of the component. For example, the \class{iNZFilterData} class contains a \fct{filter\_data} method. These main functions collect the user's input and pass them to one or more \emph{wrapper} functions; in the case of \class{iNZFilterData}, one of the functions is \fct{iNZightTools::filterNumeric}. A skeleton example of the \menu{Filter Data} window class is shown below:
\begin{Code}
iNZFilterData <- setRefClass(
    "iNZFilterData",
    propoerties = list(
        GUI = "ANY",
        data = "data.frame",
        type = "ANY",
        variable = "ANY",
        operator = "ANY",
        value = "ANY",
        ...
    ),
    methods = list(
        initialize = function(gui) {
            initFields(GUI = gui, data = gui$getActiveData())
            # ... construct GUI inputs ...
            # e.g.,
            variable <<- gcombobox(colnames(data))
            okbtn <- gbutton("Filter", handler = function(h, ...) filter_data())
        },
        filter_data = function() {
            filtered_data <- switch(type,
                "numeric" = iNZightTools::filterNumeric(
                    data,
                    var = variable,
                    op = operator,
                    num = value),
                ...
            )
            GUI$update_data(filtered_data)
        }
    )
)
\end{Code}
In this oversimplified example, the user will be displayed a drop down \fct{gcombobox} to choose a variable to filter on. When they click the button, the data will be filtered and passed back to the main \gls{gui}. The filtering uses the \fct{switch} function to select the wrapper based on the users selection (not shown to save space).


Each major component has a similiar structure, and calls to various functions, many of which come from wrappers in other \pkg{iNZight*} packages. For example, plots are generated by calls to \fct{iNZightPlots::inzplot}, while data import is handled by \fct{iNZightTools::smart\_read}. This function uses the file extension to guess the file type and load the data using the appropriate methods. The wrappers enfore the desired structure, where the interface asks for the values of arguments to be passed, and keeps the data-specific logic out of the \gls{gui}.

<<quick_hack,echo=FALSE>>=
code <- function(x) tidy_all_code(iNZightTools::code(x))
url <- "https://www.stat.auckland.ac.nz/~wild/data/test/nls.dta"
if (!file.exists("nls.dta"))
    download.file(url, "nls.dta")
@
A second advantage is that the individual wrapper functions can be designed to include the lower-level \proglang{R} code used to generate the result, which the \gls{gui} can fetch from the returned data and attach to the script. Here is an example of the result returned by \fct{iNZightTools::smart\_read} (which can read from a remote URL):
<<code_from_result>>=
library("iNZightTools")
data <- smart_read("nls.dta")
cat(code(data), sep = "\n")
@
The \fct{iNZightTools::code} function returns the \proglang{R} code attached to the resulting object, allowing a user to see that the \pkg{haven} package \citep{haven} was used to read this \proglang{Stata} file (\code{.dta}).

While the \gls{gui} packages provide the structure of the visual \gls{gui}, it's the collection of \proglang{R} packages developed alongside \pkg{iNZight} that are the powerhouses of the program. The main reason for creating separate packages was to force the separation of interface and data logic, but also to allow the parallel development of a separate interface (\cref{sec:online}) using the same wrapper functions. The collection of packages within the \pkg{iNZight} project are described in TABLE.


<<inzight_pkgs,echo=FALSE,results=tex>>=
library(magrittr)
library(kableExtra)

pkgs <- c(
    "\\pkg{iNZight}" = 'The main package for the \\gls{gui}',
    "\\pkg{iNZightModules}" = "An additional \\gls{gui} package providing additional modules for the main \\pkg{iNZight} program.",
    "\\pkg{iNZightPlots}" = "Provides plot function \\fct{inzplot} along with \\fct{inzsummary} for descriptive statistics and \\fct{inzinference} for inference and hypothesis testing.",
    "\\pkg{iNZightRegression}" = "Plots and summaries of regression models, including from \\fct{lm}, \\fct{glm}, and \\fct{survey::svyglm} objects.",
    "\\pkg{iNZightTS}" = "Time series visualisation, decomposition, and forecasting.",
    "\\pkg{iNZightMR}" = "Visualisation and estimation of multiple response data.",
    "\\pkg{iNZightTools}" = 'A suite of helper functions for data process and variable manipulation.'
)
tab <- data.frame(Package = names(pkgs), Description = as.character(pkgs))
knitr::kable(tab, "latex", booktabs = TRUE,
    caption = 'iNZight R package family',
    label = 'inzight_pkgs',
    linesep = "",
    escape = FALSE) %>%
    column_spec(2, width = "10cm") %>%
    kable_styling(font_size = 8)
@


\begin{itemize}
    \item (not sure where to put this) diving deeper: data stored in \emph{Documents}, each with a dataset/info about it; plots settings, variable choices, etc
    \begin{itemize}
        \item users can switch between documents (data sets)
        \item or merge them
    \end{itemize}
\end{itemize}


\subsection{Usage}\label{sec:usage}

At its core, \pkg{iNZight} is simply an \proglang{R} package that can be installed and run like any other, which is covered in \cref{sec:installation}. Once installed, the main program can be started by creating a new instance of the main \gls{gui} class \class{iNZGUI}, as demonstrated below.
<<manual_usage,eval=FALSE>>=
library("iNZight")
ui <- iNZGUI$new()
ui$initializeGui()
@
For most users, however, the simpler wrapper function \fct{iNZight} can be called instead. This can optionally take a \code{data} argument, which will launch \pkg{iNZight} with the data loaded and ready to explore.

For development purposes, the former startup method is recommended, as this provides access to the \class{iNZGUI} object created to explore states and trigger actions for easier testing. In these two lines, the first returns the current data, while the second sets the first variable drop down value to \code{height}.
<<manual_usage,eval=FALSE>>=
ui$getActiveData()
ui$ctrlWidget$V1box$set_value("height")
@
