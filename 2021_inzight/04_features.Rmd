---
title: Features
---

# Features of iNZight

At its heart, iNZight is a data visualisation and exploration tool for those users with little to no prior experience with data science or statistics, and who lack the programming demands of more mainstream tools such as Python @citep:python; and R @citep:rcore;. Therefore, many of the main features relate to exploring data through visualisation, with some data manipulation techniques built in, including specification of survey designs which are automatically incoporated into the rest of iNZight. Since many users will likely want to move on to coding, and since iNZight is built with R, we provide the code history for actions the user makes.



## Data wrangling

The first thing most users will want to do is import their data. iNZight provides an easy to use *Import Data* window which uses the file extension to detect the file type and provide a preview of the data in the same window. This allows users to quickly see if everything is OK and, if necessary, adjust some of the type-specific options to get it correct. An example of this might be reading european CSV files, which use a semi-colon delimiter instead of a comma.


Once loaded, iNZight provides several important data operations, allowing users to reshape, filter, and otherwise transform their dataset. Many of these 'workflows' are taken from "R for Data Science" @citep:Wickham_2017;. These basic dataset operations are implemented using packages from the 'tidyverse' @citep:tidyverse;. For each, the @gls:gui; provides an interface with inputs corresponding to various arguments, generating an R code call which is evaluated and stored in the script. In some cases, a preview of the resulting dataset is provided, making it easier for users to investigate the result of different options. FIGUREX shows the reshape data window, allowing users to convert from wide format to long format, which is more useful for plotting.

```{r screenshot-one,eval=FALSE,echo=FALSE,message=FALSE,warning=FALSE}
if (R.Version()$os == "linux-gnu") {

    library(iNZight)
    ui <- iNZGUI$new()
    ui$initializeGui(census.at.school.500)
    Sys.sleep(5) # wait for it to do its thing

    cmd <- sprintf(
        "scrot --focused '%s' -e 'mv $f %s'",
        "inzight_main.png",
        "figure/"
    )
    system(cmd)

    ui$close()
}
```

* uses 'tidyverse' methods and workflows to perform some data transformation
* all are calls to wrappers inside the 'iNZightTools' package
* the interface allows users to manipulate arguments to the wrapper function - reactive in some cases (i.e., inputs appear/disappear or change values based on previous inputs)
* in many cases, a preview is displayed to help with what can be complex actions, e.g.

As well as the dataset operations are *variable manipulations*, allowing users to modify individual variables in the data. For example, simple transformations (log, square-root) to renaming or reordering levels of a categorical variable, each has its own interface window that interfaces with 'tidyverse' code to perform the operations. And, if the operation you want is not available, you can specify a custom command to create a new variable.

The goal of these features is to allow users to import a range of data sets in a range of formats and convert them into a form useful for plotting---that is, *tidy format* @citep:Wickham_2017;, where each row contains a single set of observations about an individual.


## Graphics and simple data analyses

The foremost tool in iNZight's inventory is graphics, which are chosen automatically based on the users's chosen variables. For example, a numeric variable is displayed to the user as a dot plot or, if there are more than 5000~observations, a histogram, without the user needing to choose this first. A factor (refered to within iNZight as *categorical*) shows as a bar graph. This means the user focusses on exploring the data without the need to first *understand* the data.

In many other data analysis programs, graphs are created by the user first selecting the *type* of graph to display, and then choosing the variable. In an explorative sense, this makes little sense, as for example a variable called "age" might be numeric *or* categorical (for example age groups). The basic types of graphs available in 'iNZight' are shown in @cref:tab:inzplottypes;. \Cref:tab:inzplotlarge; shows "large sample" alternatives which are used when sample sizes exceed `r iNZightPlots::inzpar()$large.sample.size - 1L`.

```{r inzplottypes,echo=FALSE,message=FALSE,warning=FALSE,results='asis'}
library(iNZightPlots)
data(census.at.school.500, package = "iNZight")
if (!dir.exists("figure")) dir.create("figure")

d <- 4
pdf("figure/pdot.pdf", height = d, width = d, onefile = FALSE)
inzplot(~height, data = census.at.school.500)
capture.output(dev.off()) -> x

pdf("figure/pdotc.pdf", height = d, width = d, onefile = FALSE)
inzplot(height ~ gender, data = census.at.school.500)
capture.output(dev.off()) -> x

pdf("figure/pscatter.pdf", height = d, width = d, onefile = FALSE)
inzplot(height ~ armspan, data = census.at.school.500)
capture.output(dev.off()) -> x

pdf("figure/pbar.pdf", height = d, width = d, onefile = FALSE)
inzplot(~travel, data = census.at.school.500)
capture.output(dev.off()) -> x

pdf("figure/pbar2.pdf", height = d, width = d, onefile = FALSE)
inzplot(travel~gender, data = census.at.school.500, hide.legend = TRUE)
capture.output(dev.off()) -> x

# plot_types <- rbind(
#     c("Numeric", "", "dot plot", "histogram"),
#     c("Numeric", "Categorical", "dot plot", "histogram"),
#     c("Numeric", "Numeric", "scatter plot", "hexbin plot"),
#     c("Categorcal", "", "bar graph", "bar graph"),
#     c("Categorical", "Categorical", "bar graph", "two-way bar graph"),
#     c("Categorical", "Numeric", "dot plot", "histogram")
# )
# colnames(plot_types) <- c("Variable 1", "Variable 2", "Default plot", "Large-sample plot")
fig <- function(...)
    sapply(list(...),
        function(z)
            sprintf("\\includegraphics[width=0.25\\textwidth,valign=T]{figure/p%s.pdf}", z)
    )

plot_types <- data.frame(
    "Variable 1" = c("Categorical", "Numeric"),
    "None" = fig("bar", "dot"),
    "Categorical" = fig("bar2", "dotc"),
    "Numeric" = fig("dotc", "scatter")
)
library(kableExtra)
names(plot_types)[1] <- " "
knitr::kable(plot_types, "latex",
    booktabs = TRUE,
    caption = 'iNZight default plot types are determined by the variable type of the first variable and, if specified, the type of the second variable.',
    label = 'inzplottypes',
    escape = FALSE) %>%
    add_header_above(c("Variable 1", "Variable 2" = 3L)) %>%
    kable_styling(font_size = 8)
```

```{r inzplotlarge,echo=FALSE,message=FALSE,warning=FALSE,results='asis'}
pdf("figure/phist.pdf", height = d, width = d, onefile = FALSE)
inzplot(~height, data = census.at.school.500, largesample = TRUE,
    cex.dot = 5)
capture.output(dev.off()) -> x

pdf("figure/phex.pdf", height = d, width = d, onefile = FALSE)
inzplot(height ~ armspan, data = census.at.school.500, largesample = TRUE,
    hex.bins = 10)
capture.output(dev.off()) -> x

plot_large <- data.frame(
    Plot = c("dot plot", "scatter plot"),
    Small = fig("dot", "scatter"),
    Large = fig("hist", "hex")
)
knitr::kable(plot_large, "latex",
    booktabs = TRUE,
    caption = 'iNZight\'s alternative plots for large samples. Other plot types do not have a large sample alternative (i.e., bar charts).',
    label = 'inzplotlarge',
    escape = FALSE)
```

* all powered by 'iNZightPlots' functions
    * `inzplot()` for graphics
    * `inzsummary()` for simple summary information
    * `inzinference()` for inferencial information and hypothesis testing
* uses the variable type(s) to choose the graph type. Figure x shows the available graph types
* subsetting by 1 or 2 variables is possible/easy/emphasized
    * includes a slider to cycle or 'step' between levels (can add 'motion' to graphs; @citep:Rosling2010;)
* plot features: specific to plot type, users only see what's relevant
* some features (such as colour by) might apply to different plot types (scatter and dot plot, for example) and so selection is retained when switching between these plot types

* inferencial markup of plots
    * normal theory error bars/curves
    * or bootstrap alternative
    * "Comparison intervals" are a way of visually assessing differences - only shown on differences *that should be compared* - bar plot example
    * an approximate tukey thing? details needed here ('iNZightMR' package)

* summary information
    * a simple numeric summary *of the current plot* (philosophy: look first)
* inference information
    * again, default inferences *of the current plot*
    * both normal and bootstrap options
    * gives a list of relevant hypothesis tests (cf. other software which requires you to decide on hypothesis test first)


## Saving code history

* many functions (the wrappers) generate code and attach it to their result
\begin{lstlisting}[language=R]
data.filtered <- iNZightTools::filterData(iris, "Species", "Setosa")
cat(code(data.filtered))
# iris %>% dplyr::filter(Species == "Setosa")
\end{lstlisting}

* the iNZight GUI stores the attached code after each action and appends it to the R history 'script'
* provides a record of what was done
* helps students interested in continuing data science/statistics to get familiar with code before writing it themselves (can copy+paste and modify, for example)

## Analysing surveys with iNZight

* survey data:
    * iNZight gets told once, and everything else 'just works'
    * plots use survey methods and alternative plot types (histogram vs dotplot; hex bin plot vs scatter plot)
    * summary/inference all use survey methods to obtain summaries/inferences/hypothesis tests

* supports strata/cluster based survey designs, replicate weights, and post-stratification


## Other modules

* A suite of other (fixed) modules for analying/exploring special types of data
    * time series
    * multiple response
    * maps
* or for doing specific tasks
    * model fitting

* each is its own "reference class" object connecting to one (or more) functions in another package
    * time series -> 'iNZightTS'
    * multiple response -> 'iNZightMR'
    * maps -> 'iNZightMaps'
    * model fitting -> 'iNZightRegression'
* these are mostly wrappers to other functions, or modified versions -> made to work as 'standalone' packages (i.e., without iNZight)
* not fully implemented, but making progress towards modules also code-writing

* also a newer add-on system allowing anyone to write new modules for iNZight (added manually or through our github-hosted repository)
* easier/faster to maintain/update
* useful for e.g., teachers of a specific course
