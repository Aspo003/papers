---
title: Features
---

# Features of iNZight

At its heart, iNZight is a data visualisation and exploration tool for those users with little to no prior experience with data science or statistics, and who lack the programming demands of more mainstream tools such as Python @citep:python; and R @citep:rcore;. Therefore, many of the main features relate to exploring data through visualisation, with some data manipulation techniques built in, including specification of survey designs which are automatically incoporated into the rest of iNZight. Since many users will likely want to move on to coding, and since iNZight is built with R, we provide the code history for actions the user makes.



## Data wrangling

The first thing most users will want to do is import their data. iNZight provides an easy to use *Import Data* window which uses the file extension to detect the file type and provide a preview of the data in the same window. This allows users to quickly see if everything is OK and, if necessary, adjust some of the type-specific options to get it correct. An example of this might be reading european CSV files, which use a semi-colon delimiter instead of a comma.


Once loaded, iNZight provides several important data operations, allowing users to reshape, filter, and otherwise transform their dataset. Many of these 'workflows' are taken from "R for Data Science" @citep:Wickham_2017;. These basic dataset operations are implemented using packages from the 'tidyverse' @citep:tidyverse;. For each, the @gls:gui; provides an interface with inputs corresponding to various arguments, generating an R code call which is evaluated and stored in the script. In some cases, a preview of the resulting dataset is provided, making it easier for users to investigate the result of different options. FIGUREX shows the reshape data window, allowing users to convert from wide format to long format, which is more useful for plotting.

```{r screenshot-one,eval=FALSE,echo=FALSE,message=FALSE,warning=FALSE}
if (R.Version()$os == "linux-gnu") {

    library(iNZight)
    ui <- iNZGUI$new()
    ui$initializeGui(census.at.school.500)
    Sys.sleep(5) # wait for it to do its thing

    cmd <- sprintf(
        "scrot --focused '%s' -e 'mv $f %s'",
        "inzight_main.png",
        "figure/"
    )
    system(cmd)

    ui$close()
}
```

* uses 'tidyverse' methods and workflows to perform some data transformation
* all are calls to wrappers inside the 'iNZightTools' package
* the interface allows users to manipulate arguments to the wrapper function - reactive in some cases (i.e., inputs appear/disappear or change values based on previous inputs)
* in many cases, a preview is displayed to help with what can be complex actions, e.g.

As well as the dataset operations are *variable manipulations*, allowing users to modify individual variables in the data. For example, simple transformations (log, square-root) to renaming or reordering levels of a categorical variable, each has its own interface window that interfaces with 'tidyverse' code to perform the operations. And, if the operation you want is not available, you can specify a custom command to create a new variable.

The goal of these features is to allow users to import a range of data sets in a range of formats and convert them into a form useful for plotting---that is, *tidy format* @citep:Wickham_2017;, where each row contains a single set of observations about an individual.


## Graphics and simple data analyses

The foremost tool in iNZight's inventory is graphics, which are chosen automatically based on the users's chosen variables. For example, a numeric variable is displayed to the user as a dot plot or, if there are more than 5000~observations, a histogram, without the user needing to choose this first. A factor (refered to within iNZight as *categorical*) shows as a bar graph. This means the user focusses on exploring the data without the need to first *understand* the data.

In many other data analysis programs, graphs are created by the user first selecting the *type* of graph to display, and then choosing the variable. In an explorative sense, this makes little sense, as for example a variable called "age" might be numeric *or* categorical (for example age groups). The basic types of graphs available in 'iNZight' are shown in @cref:tab:inzplottypes;. @Cref:tab:inzplotlarge; shows "large sample" alternatives which are used when sample sizes exceed `r iNZightPlots::inzpar()$large.sample.size - 1L`. The three basic plot types are *bar charts* for exploring categorical variables, *dot plots* for exploring a single numeric variable (and possibly its relationship with another categorical variable), and *scatter plots* for exploring the relationships between two numeric variables. *Histograms* are are more useful way of exploring the distribution of values a numeric variable takes when the sample size is large (that is, seeing individual points is no longer useful, nor aesthetically pleasing), while *hexagonally binned plots* are used to replace scatter plots in the same situation, allowing users to see where the bulk of points are located. Of course, this is not the only way to look at large data, which I will get to shortly.

```{r inzplottypes,echo=FALSE,message=FALSE,warning=FALSE,results='asis'}
library(iNZightPlots)
data(census.at.school.500, package = "iNZight")
if (!dir.exists("figure")) dir.create("figure")

d <- 4
pdf("figure/pdot.pdf", height = d, width = d, onefile = FALSE)
inzplot(~height, data = census.at.school.500)
capture.output(dev.off()) -> x

pdf("figure/pdotc.pdf", height = d, width = d, onefile = FALSE)
inzplot(height ~ gender, data = census.at.school.500)
capture.output(dev.off()) -> x

pdf("figure/pscatter.pdf", height = d, width = d, onefile = FALSE)
inzplot(height ~ armspan, data = census.at.school.500)
capture.output(dev.off()) -> x

pdf("figure/pbar.pdf", height = d, width = d, onefile = FALSE)
inzplot(~travel, data = census.at.school.500)
capture.output(dev.off()) -> x

pdf("figure/pbar2.pdf", height = d, width = d, onefile = FALSE)
inzplot(travel~gender, data = census.at.school.500, hide.legend = TRUE)
capture.output(dev.off()) -> x

# plot_types <- rbind(
#     c("Numeric", "", "dot plot", "histogram"),
#     c("Numeric", "Categorical", "dot plot", "histogram"),
#     c("Numeric", "Numeric", "scatter plot", "hexbin plot"),
#     c("Categorcal", "", "bar graph", "bar graph"),
#     c("Categorical", "Categorical", "bar graph", "two-way bar graph"),
#     c("Categorical", "Numeric", "dot plot", "histogram")
# )
# colnames(plot_types) <- c("Variable 1", "Variable 2", "Default plot", "Large-sample plot")
fig <- function(...)
    sapply(list(...),
        function(z)
            sprintf("\\includegraphics[width=0.25\\textwidth,valign=T]{figure/p%s.pdf}", z)
    )

plot_types <- data.frame(
    "Variable 1" = c("Categorical", "Numeric"),
    "None" = fig("bar", "dot"),
    "Categorical" = fig("bar2", "dotc"),
    "Numeric" = fig("dotc", "scatter")
)
library(kableExtra)
names(plot_types)[1] <- " "
knitr::kable(plot_types, "latex",
    booktabs = TRUE,
    caption = 'iNZight default plot types are determined by the variable type of the first variable and, if specified, the type of the second variable.',
    label = 'inzplottypes',
    escape = FALSE) %>%
    add_header_above(c("Variable 1", "Variable 2" = 3L)) %>%
    kable_styling(font_size = 8)
```

```{r inzplotlarge,echo=FALSE,message=FALSE,warning=FALSE,results='asis'}
pdf("figure/phist.pdf", height = d, width = d, onefile = FALSE)
inzplot(~height, data = census.at.school.500, largesample = TRUE,
    cex.dot = 5)
capture.output(dev.off()) -> x

pdf("figure/phex.pdf", height = d, width = d, onefile = FALSE)
inzplot(height ~ armspan, data = census.at.school.500, largesample = TRUE,
    hex.bins = 10)
capture.output(dev.off()) -> x

plot_large <- data.frame(
    Plot = c("dot plot", "scatter plot"),
    Small = fig("dot", "scatter"),
    Large = fig("hist", "hex")
)
knitr::kable(plot_large, "latex",
    booktabs = TRUE,
    caption = 'iNZight\'s alternative plots for large samples. Other plot types do not have a large sample alternative (i.e., bar charts).',
    label = 'inzplotlarge',
    escape = FALSE)
```

Another way of exploring relationships is by *subsetting* or *faceting*, which is easily accessed and indeed encouraged from the iNZight interface. The two subsetting variable slots allow users to subset the plot, which presents a slider to look at individual levels of the chosen variable, as shown in @cref:fig:subsetslider;. This is particularly advantageous to exploring trends *over time*, as users can use the "Play" button and watch as iNZight automatically plays over the range of levels (which might be "years" in a longitudinal dataset). This use of motion to explore trends in the data over time was most famously demonstated by @citet:Rosling_2010; in his BBC documentary "The Joy of Stats". However, time is not the only useful subsetting variable: many other categorical variables are often important when exploring relationships in a dataset, for example age and ethnicity.


Of course, there is only so much one can learn from subsetting, and often more advanced visualisation techniques are required. For this, iNZight provides the *Add to Plot* system, which displays a list of options for the user to adjust, and most importantly only those related to the current plot. The most notable feature is *colour*, which can either be set to a single colour or, more usefully, coded to another variable in the dataset. This panel is also reactive, so a user's choices will open up some new options (or remove others), allowing them to explore the possibilities offered without having problems (for example trying to colour a bar chart by a numeric variable). Other codable features include *point size* and *point shape* (useful for printed media or for colourblind audiences).

Other options under the *Add to Plot* system include adjusting axes (by adding transformations or changing labels), adding additional information to specific plots (trend lines and smoothers to scatter plots, for example), and *locating points*. The last of these is an essential part of data exploration: often we want to explore outliers or else identify a specific point in the data. iNZight allows users to use a *point-and-click* identification method to highlight and label specific points, which are retained in future plots (so an individual can be tracked over different variables to explore them in detail), or points can be identified contextually, either by their specific value, or as an "extreme" value.

Since switching variables often results in a change of plot, iNZight remembers most settings (for example *colour*) so those variables remain visible in the dataset. This makes it easy to explore, for example, the effect of ethnicity on other variable relationships. Since some plots do not handle all arguments, iNZight only uses those that do: for example, switching to a two-way bar plot, the "colour" variable would be ignored without being forgotten; changing back to, say, a scatter plot reactivates the colour variable.

<!--
* all powered by 'iNZightPlots' functions
    * `inzplot()` for graphics
    * `inzsummary()` for simple summary information
    * `inzinference()` for inferencial information and hypothesis testing
* uses the variable type(s) to choose the graph type. Figure x shows the available graph types
* subsetting by 1 or 2 variables is possible/easy/emphasized
    * includes a slider to cycle or 'step' between levels (can add 'motion' to graphs; @citep:Rosling_2010;)
* plot features: specific to plot type, users only see what's relevant
* some features (such as colour by) might apply to different plot types (scatter and dot plot, for example) and so selection is retained when switching between these plot types
-->


Visually assessing relationships in the dataset is generally the first step in a more in-depth analysis, and often we find that what we thought was an effect is actually not significant. iNZight provides some simple *visual inferencial markup*
to plots that provide a visual way of exploring if a particular relationship might actually be there, or is simply a function of randomness. For example, a bar chart often hides the underlying population size, so the significance of differences in bar height is not obvious. By adding error bars, however, we can begin to make inferential calls about those differences. Another example is the trend line on a scatter plot: the sample estimate might display an upwards trend, but this may be affected by just a few points. By adding a sample of *bootstrap trend curves*, as shown in @cref:fig:scatter_bs_trend;, we can assess how *real* this relationship might be.

```{r scatter_bs_trend,echo=FALSE,fig.height=5,fig.width=6,out.width="0.8\\textwidth",fig.cap="A scatter plot with a linear trend, showing a bootstrap sample of trend curves.",fig.align="center"}
inzplot(armspan ~ height, data = census.at.school.500, trend = "linear", bs.inference = TRUE)
```

Another type of *visual inference* iNZight offers is *comparison intervals*, estimated using the 'iNZightMR' package @citep:iNZightMR;. These intervals provide adjusted intervals designed primarily for visual comparison. In the two-way bar chart shown in @cref:fig:barchart_comp;, the *within group* comparison intervals can be interpreted as "if the intervals do not overlap, then for a particular level of 'travel' there may be a different between the proportions for each 'gender'"; in the figure, the appears to be a difference between the proportion of males and females who travel by bike, but otherwise the distribution of travel is the same. It is important to note that these *are not* confidence intervals: they account for multiple comparisons and the covariance between variables.

```{r barchart_comp,echo=FALSE,fig.height=5,fig.width=6,out.width="0.8\\textwidth",fig.cap="A two-way bar chart with comparison intervals.",fig.align="center"}
inzplot(travel ~ gender, data = census.at.school.500, inference.type = "comp")
```

<!--
* inferencial markup of plots
    * normal theory error bars/curves
    * or bootstrap alternative
    * "Comparison intervals" are a way of visually assessing differences - only shown on differences *that should be compared* - bar plot example
    * an approximate tukey thing? details needed here ('iNZightMR' package)
-->

Having done as must visual exploration as iNZight provides, it is likely that some numerical information might be desired. For example, when discussing the data it is useful to have summary statistics, such as the mean or quantiles. iNZight provides a "Get Summary" button, which provides a simple summary of the currently displayed graph. Like the plots, the types of summaries depends on the chosen variable(s) and, in some cases, additional features (scatter plots provide extra information about the basic relationship of any fitted trend lines, for example). The primary use is to extract values from the graph, with a few extra variables (such as variance) which are considered simple summaries. The philosophy remains "look first". A simple summary of a dotplot is given in @cref:fig:dot_summary;.

\begin{figure}
\centering
\includegraphics[width=0.8\textwidth]{figure/dot_summary.png}
\caption{The ``Get Summary'' window for a numeric variable (`height').}\label{fig:dot_summary}
\end{figure}

Once visual and numeric exploration has been complete, the next step is often to pose and test hypotheses. Again, iNZight provides this functionality through the simple "Get Inference" button, and works similarly to "Get Summary", but with a few slight differences. The type of inference information and hypothesis tests available depend on the chosen variables, though users are also presented with some controls to specify information about their hypothesis. Additionally, *bootstrap inference* is provided which uses bootstrap sampling using the 'boot' package @citep:boot; to obtain inferences. The basic inferences include confidence intervals for most parameters, as well as $p$-values of differences (in a two-way table of counts, for example).

The choices of hypothesis test depend also on the variable types. For a sole numeric variable, a one-sample *t*-test is available in which the hypothesis value can be specified, and either a one- or two-sided test carried out. \Cref{tab:hypothesis-tests} shows the types of hypothesis tests available from iNZight.

```{r hypothesis-tests,echo=FALSE,results='asis',message=FALSE,warning=FALSE}
tab <- cbind(
    c('numeric', 'categorical', ''),
    c('', '2 levels', '2+ levels'),
    c('t-test$^1$', 'single proportion', '$\\chi^2$-test$^2$'),
    c('--', 't-test$^3$', 'ANOVA'),
    c('t-test$^3$', '$\\chi^2$-test$^{4,5}$', '$\\chi^2$-test$^4$'),
    c('ANOVA', '$\\chi^2$-test$^{4,5}$', '$\\chi^2$-test$^4$')
)
kable(tab,
    "latex",
    booktabs = TRUE,
    caption = 'iNZight hypothesis test options. ',
    label = 'hypothesis-tests',
    # align = "center",
    escape = FALSE) %>%
    add_header_above(c('', '', 'NULL', 'numeric', '2 level cat', '2+ level cat')) %>%
    add_header_above(c("Variable 1" = 2L, "Variable 2" = 4L)) %>%
    add_footnote(
        c(
            'One-sample',
            'Equal proportions',
            'Two-sample',
            'Equal distributions',
            'Additionally includes epidemiological output such as odds and risk ratios.'
        ),
        'number', threeparttable = TRUE) %>%
    kable_styling(font_size = 8)
```

This concludes the main functionality of iNZight for beginners: the ablity to load a data set and instantly view graphs and summary information, and perform hypothesis tests without having to understand how these fit together. iNZight provides a platform with with learners can explore on their own, and learn as they go.


## Saving code history

* many functions (the wrappers) generate code and attach it to their result
\begin{lstlisting}[language=R]
data.filtered <- iNZightTools::filterData(iris, "Species", "Setosa")
cat(code(data.filtered))
# iris %>% dplyr::filter(Species == "Setosa")
\end{lstlisting}

* the iNZight GUI stores the attached code after each action and appends it to the R history 'script'
* provides a record of what was done
* helps students interested in continuing data science/statistics to get familiar with code before writing it themselves (can copy+paste and modify, for example)

## Analysing surveys with iNZight

* survey data:
    * iNZight gets told once, and everything else 'just works'
    * plots use survey methods and alternative plot types (histogram vs dotplot; hex bin plot vs scatter plot)
    * summary/inference all use survey methods to obtain summaries/inferences/hypothesis tests

* supports strata/cluster based survey designs, replicate weights, and post-stratification


## Other modules

* A suite of other (fixed) modules for analying/exploring special types of data
    * time series
    * multiple response
    * maps
* or for doing specific tasks
    * model fitting

* each is its own "reference class" object connecting to one (or more) functions in another package
    * time series -> 'iNZightTS'
    * multiple response -> 'iNZightMR'
    * maps -> 'iNZightMaps'
    * model fitting -> 'iNZightRegression'
* these are mostly wrappers to other functions, or modified versions -> made to work as 'standalone' packages (i.e., without iNZight)
* not fully implemented, but making progress towards modules also code-writing

* also a newer add-on system allowing anyone to write new modules for iNZight (added manually or through our github-hosted repository)
* easier/faster to maintain/update
* useful for e.g., teachers of a specific course
