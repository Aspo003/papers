---
title: History
---

# An overview of iNZight's structure

Producing cross-platform @glspl:gui; has always been a difficult task as different @glspl:os; implement different display devices. Therefore many projects have been created in an attempt to make cross-platform applications a possibility. One such example is GTK+, which is implemented on Windows, macOS, and Linux systems, providing a single toolkit for creating @glspl:gui; for all major systems @citep:gtk;.

Of course, interfacing with such a framework is in itself a difficult job, and requires some complex C++ coding. Fortunately, several interfacing packages have been written in R which prove a simple, platform (and indeed toolkit) independent @gls:api; for writing @glspl:gui; from R. The 'RGtk2' package @citep:RGtk2; provides an platform-independent interface between R and GTK+2, allowing access to most of the classes to construct a @gls:gui; that reacts to a user's input. Additionally, the 'gWidgets2' package @citep:gWidgets2; provides a framework-independent inteface between R and several other R packages responsible to creating @glspl:gui;, namely 'gWidgets2RGtk2' for communicating with 'RGtk2' @citep:gWidgets2RGtk2;. Together, these packages make it possible for any R programming to construct a graphical application without any knowledge of GTK or platform-specific development. Indeed, it is the combination of these tools which made it possible for statistics students to create and work on 'iNZight'.

Given a platform- and framework-independent @gls:api;, the next critical step is planning the internal structure of the application, most importantly ensuring that future development will not become hindered by early decisions. The most foundational decision in the early development of 'iNZight' was to separate *form* from *function*: that is, the code the controls the interface should be, as far as possible, separate from the code that handles data processing, graphics, and so on. Further, we wanted the individual components of the @gls:gui; to be independent to ensure future development would be easier: for example, buttons can be moved and replaced, and new components can be added or old ones removed without affecting anything else. The necessity for @gls:oop; was clear, so that each individual component is represented by a single *class*, which could be modified independently of others, or modified ("inheritance") to make similar widgets with common behaviours but several unique features.


* \checkmark Many of the features come from design-flexibility
* \checkmark Separation of @gls:gui; and data processing
* \checkmark Relies mainly on 'gWidgets2' and 'gWidgets2RGtk2' @citep:gWidgets2,gWidgets2RGtk2; to interface with the user, and reference classes to structure the code base
* \checkmark internally, each component of the @gls:gui; is represented by a single class - this makes it easy to extend and modify iNZight
* data/variable manipulation windows each are a single class, which connects to a helper function in another package (usually inside 'iNZightTools' @citep:iNZightTools;)
* A key design feature is that the @gls:gui; asks the users for inputs, which are passed to a single function as arguments - this allows not only separation, but also for other @glspl:gui; (for example iNZight Lite) to connect to the same functions
* Additionally, those simple wrapper functions can be accessed by beginners not yet ready for the more complex coding required to do the same things

\begin{lstlisting}[language=R,caption=A simple reference class window to filter a level of a factor.,label={lst:rc_filter_example}]
# A simple window to filter a level of a categorical variable
filterWin <- setRefClass('filterWin',
    fields = list(
        GUI = "ANY",
        data = "data.frame",
        variable = "ANY",
        level = "ANY"
    ),
    methods = list(
        initialize = function(gui) {
            initFields(GUI = gui, data = gui$getActiveData())
            win <- gwindow('Filter Level')
            cont <- gvbox(container = win)
            variable <<- gcombobox(names(data), container = cont)
            level <<- gedit("", container = cont)
            okbtn <- gbutton("Filter")
            addHandlerClicked(okbtn, function(h, ...) filterData())
        },
        filterData = function() {
            var <- svalue(variable)
            level <- svalue(level)
            newdata <- iNZightTools::filterLevels(data, var, level)
            GUI$set_data(newdata)
            dispose(win)
        }
    )
)
\end{lstlisting}

* examples:
    * `iNZightTools::smart_read()` imports a dataset based on its extension - user doesn't need to know `read_csv()`, `read_dta()`, etc
    * `iNZightPlots::inplot()` is the main power-house function within iNZight - takes UI inputs and generates a graph based on the variable types (and other selections)
    * both of these functions can be accessed directly from R
    * most also return the 'tidyverse' code so learners can get a taste for the actual code necessary to do stuff (e.g., filtering data, etc)

```{r inzight_pkgs,echo=FALSE,results='asis'}
library(magrittr)
library(kableExtra)

pkgs <- c(
    "iNZight" = 'The main package for the GUI',
    "iNZightPlots" = 'Provides plot function `inzplot()` along with `inzsummary()` for descriptive statistics and `inzinference()` for inference and hypothesis testing.',
    "iNZightTools" = 'A suite of helper functions for data process and variable manipulation.'
)
tab <- data.frame(Package = names(pkgs), Description = as.character(pkgs))
knitr::kable(tab, "latex", booktabs = TRUE,
    caption = 'iNZight R package family',
    label = 'tab:inzight_pkgs') %>%
    column_spec(2, width = "8cm") %>%
    kable_styling(font_size = 8)
```